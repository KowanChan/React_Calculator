{"ast":null,"code":"// Simulated Backend for calculations\nexport function evaluate(calc) {\n  // Solve a problem recursively\n\n  /* This function will split the string given as calc into an array split by operators. If we encounter a ( weill will create a new aray.\r\n  This means that there will be nested arrays in split to represent nested parentheses. Call evaluate on any parenthesis. */\n  const ops = [\"+\", \"-\", \"/\", \"*\"];\n  const nums = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \".\"];\n  const split = [];\n  let i = 0;\n  let curr = \"\";\n\n  while (calc.charAt(i) != \"\") {\n    if (nums.includes(calc.charAt(i))) {\n      curr += calc.charAt(i);\n    } else if (ops.includes(calc.charAt(i))) {\n      split.push(curr);\n      curr = \"\";\n      split.push(calc.charAt(i));\n    } else if (calc.charAt(i++) == \"(\") {\n      evaluate(calc.slice(i));\n    } else if (calc.charAt(i++) == \")\") {\n      return split;\n    }\n\n    i++;\n  }\n\n  let word = \"\";\n\n  for (const element of split) {\n    word = word + element + \" \";\n  }\n\n  return word;\n}","map":{"version":3,"sources":["C:/Users/Kowan/ReactProjects/calculator/src/backend2.js"],"names":["evaluate","calc","ops","nums","split","i","curr","charAt","includes","push","slice","word","element"],"mappings":"AAAA;AACA,OAAO,SAASA,QAAT,CAAkBC,IAAlB,EAAuB;AAC7B;;AAEA;AACD;AACC,QAAMC,GAAG,GAAG,CAAC,GAAD,EAAK,GAAL,EAAS,GAAT,EAAa,GAAb,CAAZ;AACA,QAAMC,IAAI,GAAG,CAAC,GAAD,EAAK,GAAL,EAAS,GAAT,EAAa,GAAb,EAAiB,GAAjB,EAAqB,GAArB,EAAyB,GAAzB,EAA6B,GAA7B,EAAiC,GAAjC,EAAqC,GAArC,EAAyC,GAAzC,CAAb;AAEA,QAAMC,KAAK,GAAG,EAAd;AAEA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,IAAI,GAAG,EAAX;;AACA,SAAML,IAAI,CAACM,MAAL,CAAYF,CAAZ,KAAkB,EAAxB,EAA2B;AAC1B,QAAIF,IAAI,CAACK,QAAL,CAAcP,IAAI,CAACM,MAAL,CAAYF,CAAZ,CAAd,CAAJ,EAAmC;AAClCC,MAAAA,IAAI,IAAIL,IAAI,CAACM,MAAL,CAAYF,CAAZ,CAAR;AACA,KAFD,MAIK,IAAIH,GAAG,CAACM,QAAJ,CAAaP,IAAI,CAACM,MAAL,CAAYF,CAAZ,CAAb,CAAJ,EAAkC;AACtCD,MAAAA,KAAK,CAACK,IAAN,CAAWH,IAAX;AACAA,MAAAA,IAAI,GAAG,EAAP;AACAF,MAAAA,KAAK,CAACK,IAAN,CAAWR,IAAI,CAACM,MAAL,CAAYF,CAAZ,CAAX;AACA,KAJI,MAMA,IAAIJ,IAAI,CAACM,MAAL,CAAYF,CAAC,EAAb,KAAoB,GAAxB,EAA6B;AACjCL,MAAAA,QAAQ,CAACC,IAAI,CAACS,KAAL,CAAWL,CAAX,CAAD,CAAR;AACA,KAFI,MAIA,IAAIJ,IAAI,CAACM,MAAL,CAAYF,CAAC,EAAb,KAAoB,GAAxB,EAA6B;AACjC,aAAOD,KAAP;AACA;;AACDC,IAAAA,CAAC;AACD;;AAED,MAAIM,IAAI,GAAG,EAAX;;AAEA,OAAK,MAAMC,OAAX,IAAsBR,KAAtB,EAA6B;AAC5BO,IAAAA,IAAI,GAAGA,IAAI,GAACC,OAAL,GAAa,GAApB;AACA;;AACD,SAAOD,IAAP;AACA","sourcesContent":["// Simulated Backend for calculations\r\nexport function evaluate(calc){\r\n\t// Solve a problem recursively\r\n\r\n\t/* This function will split the string given as calc into an array split by operators. If we encounter a ( weill will create a new aray.\r\n\tThis means that there will be nested arrays in split to represent nested parentheses. Call evaluate on any parenthesis. */\r\n\tconst ops = [\"+\",\"-\",\"/\",\"*\"];\r\n\tconst nums = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\".\"];\r\n\r\n\tconst split = [];\r\n\r\n\tlet i = 0;\r\n\tlet curr = \"\";\r\n\twhile(calc.charAt(i) != \"\"){\r\n\t\tif (nums.includes(calc.charAt(i))) {\r\n\t\t\tcurr += calc.charAt(i);\r\n\t\t}\r\n\r\n\t\telse if (ops.includes(calc.charAt(i))) {\r\n\t\t\tsplit.push(curr);\r\n\t\t\tcurr = \"\";\r\n\t\t\tsplit.push(calc.charAt(i));\r\n\t\t}\r\n\r\n\t\telse if (calc.charAt(i++) == \"(\") {\r\n\t\t\tevaluate(calc.slice(i));\r\n\t\t}\r\n\r\n\t\telse if (calc.charAt(i++) == \")\") {\r\n\t\t\treturn split;\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n\r\n\tlet word = \"\";\r\n\r\n\tfor (const element of split) {\r\n\t\tword = word+element+\" \"\r\n\t}\r\n\treturn word;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}